#
# Copyright (c) 2020 The Broad Institute, Inc. All rights reserved.
#
library(gplots)
library(optparse)
library(cluster)
library(Cairo)
options(stringsAsFactors=FALSE)

# replace gplots::heatmap.2 function with modified version to skip unecessary dendrogram
# creation and use the order defined in the supplied matrix.


# Select the best clustered gene groups.
#
# @param cluster Table of cluster memberships for different k. First column contains sample names with hyphens.
# @param cophenetic The file where the cophenetic coeffecients
# @param measure - Correlation measurement
# @param input_exp - Filename for the normalized expression matrix with the selected genes.
# @param output_prefix - prefix for output files
# @param cluster_membership Table of cluster memberships for different k. First column contains sample names with hyphens.
# @param input_all_exp - Matrix of normalized expression levels directly from the preprocessor with fixed samples names

option.list <- list(
  make_option(c("-b", "--cluster"), action="store", type="character", help=""),
  make_option(c("-c", "--cophenetic"), action="store", type="character", help=""),
  make_option(c("-m", "--measure"), action="store", type="character", help=""),
  make_option(c("-u", "--input_exp"), action="store", type="character", help=""),
  make_option(c("-o", "--output_prefix"), action="store", type="character", help=""),
  make_option(c("-w", "--cluster_membership"), action="store", type="character", default=getwd(), help=""),
  make_option(c("-p", "--input_all_exp"), action="store", type="character", help=""),
  make_option(c("-y", "--libdir"), default=NA, help="the src directory")
)

main <- function(opt) {
  # main function

  # @param opt: a list of options/values from optparse

  # The full expression file generated by the preprocessor (e.g. mRNA_Preprocess_Median) is
  # read and the dots "." in the sample names are replaced with hyphens "-". However, this matrix
  # does not get used to do the computation of the silhouette width. Also, the output of the
  # preprocessor used for the NCI workspaces doesn't contain dots to begin with.
  exp            <- read.data(opt$input_all_exp)
  # colnames(exp)  <- gsub("\\.", "-", colnames(exp))

  # Remove up to 2 leading non-numeric columns.
  if (all(is.na(as.numeric(exp[, 1])))) {
    exp <- exp[, -1, drop=FALSE]
    if (all(is.na(as.numeric(exp[, 1])))) {
      exp <- exp[, -1, drop=FALSE]
    }
  }

  if(dim(exp)[1] > length(unique(rownames(exp)))) {
    tnames <- rownames(exp)[duplicated(rownames(exp))]
    tt     <- which(rownames(exp) %in% tnames)
    exp    <- exp[-tt, ]
  }

	select_best_cluster(exp, opt$measure, opt$input_exp, opt$output_prefix, opt$cluster_membership, opt$cophenetic, opt$cluster)
}

select_best_cluster <- function(all_exp, measure, input_exp, output, cluster_membership, cophenetic, cluster) {
  # select the best cluster

  # @param all_exp: Matrix of normalized expression levels directly from the preprocessor with fixed samples names ("." replaced with "-")
  # @param measure:  Correlation measure.
  # @param input_exp: Filename for the normalized expression matrix with the selected genes.
  # @param output:  This is the individual set id, e.g. "LUSC".
  # @param cluster_membership: Table of cluster memberships for different k. First column contains sample names with hyphens.
  # @param cophenetic: The file where the cophenetic coeffecients can be loaded from.

  if(cluster == "cluster" | cluster == "nmf") {
    # Reading GCT or TXT file with normalized expression profiles of selected genes.
    pos  <- regexpr("\\.([[:alnum:]]+)$", input_exp)
    ext  <- ifelse(pos > -1L, substring(input_exp, pos + 1L), "")
    skip <- ifelse(ext == "gct", 2, 0)

    dism <- read.delim(input_exp, skip=skip, as.is=TRUE, header=TRUE, check.names=FALSE)

    # added 1 line: Replace "." in column names (= TCGA bar codes = sample names) with "-" to match
    # samples names in cluster membership table.
    # colnames(dism) <- gsub("\\.", "-", colnames(dism));
    tnames         <- dism[duplicated(dism[, 1]), 1]
    if(length(tnames) > 0) {
      tt   <- which(dism[, 1] %in% tnames)
      dism <- dism[-tt, ]
    }
    # Set gene names as row names.
    row.names(dism) <- dism[, 1]

    # if GCT - Remove the first two columns (gene names and description).
    # otherwise drop first column.
    if(ext == "gct") {
      dism <- as.matrix(dism[, -c(1:2)])
    } else {
      dism <- as.matrix(dism[, -1])
    }

  } else {
    dism <- all_exp
  }

  # Compute correlation matrix.
  if (measure == "pearson") {
    fdist     <- cor(dism, method="pearson", use="complete.obs")
    cormatrix <- fdist
    fdist     <- 1 - fdist
  } else if (measure == "euclidean") {
    fdist     <- dist(t(dism), method="euclidean")
    fdist     <- as.matrix(fdist)
    cormatrix <- fdist
  } else {
    stop.message <- paste0("Unsupported distance measurement: ", measure)
    stop(stop.message)
  }

  write.table(cormatrix, file=paste0(output, ".samplebysamples.txt"), sep="\t", quote=FALSE)

  # calculate silhouette value for selecting best cluster
  # read cluster membership table.
  cluster.mem <- read.delim(cluster_membership, check.names=FALSE)

  if(cluster == "cluster") {
    # use first column as rownames, drop first column
    rownames(cluster.mem) <- cluster.mem[, 1]
    cluster.mem           <- cluster.mem[, -1]
  }

  counts.na    <- colSums(is.na(fdist))

  # require at least 10 non-NA
  threshold.na <- which(counts.na > (ncol(fdist) - 10))

  if(length(threshold.na) > 0) {
    t           <- which(rownames(cluster.mem) %in% colnames(fdist)[threshold.na])
    cluster.mem <- cluster.mem[-t, ]
    fdist       <- fdist[-threshold.na, -threshold.na]
  }

  # validate rows and columns selection
  stopifnot(all(rownames(cluster.mem) %in% rownames(fdist)))
  stopifnot(all(rownames(cluster.mem) %in% colnames(fdist)))

  fdist <- fdist[rownames(cluster.mem), rownames(cluster.mem)]

  # nn = nxn = dimensions of the cluster membership table (rows = samples, columns = options for k)
  nn <- dim(cluster.mem)

  sil     <- NULL
  sil_all <- NULL
  allclu  <- NULL

  # nils: Computation of (average) silhouette widths for all options of k.
  for (i in 1:nn[2]) {
    # nils: Computation of silhouette width for the ith k.
    clu_si <- silhouette(cluster.mem[, i], fdist)

    # nils: Not sure if this is really required.
    rownames(clu_si) <- rownames(cluster.mem)

    # nils: Store average silhouette width for ith k.
    sil <- cbind(sil, mean(clu_si[, "sil_width"]))

    # nils: Store silhouette width individual samples for this k.
    sil_all <- cbind(sil_all, clu_si[, "sil_width"])
  }

  # nils: Determine k with highest silhouette width and return index.
  # WARNING: This code will never return the first index. Unclear why this is done. It forces
  # the script to always return a k > min_k (min_k is the minimum k tested).
  # Also, this could be done more elegantly with "which.max".

  # nils -- removed 2 lines: see comment above
  # t <- which(sil == max(sil[-1]))
  # kclus <- as.numeric(t)

  # Select the best cluster name and index on the basis of the cophenetic coefficient and silhouette width 
  # From the plot of cophenetic correlation versus k, we select modes and the point preceding the greatest 
  # decrease in cophenetic correlation coefficient, and from these choose the k with the highest average 
  # silhouette value.
  values <- read.delim(cophenetic)

  peak   <- NULL

  n.dim  <- nrow(values) - 1

  slope  <- sapply(1:n.dim, function(i, val) { val[i+1, 1] - val[i, 1] }, values)

  dif.slope <- slope[2:length(slope)]

  tk <- which(dif.slope == min(dif.slope)) + 1

  peak <- cbind(peak, tk)

  # TODO: Ask Hailei historical context?
  t <- which(slope >= 0)
  if(length(t) == 0) {
    # all less than or equal to zero
    t1    <- which.max(sil[peak[1, ]])
    kclus <- peak[1, t1]
  } else if (length(t) == 1){
    tk    <- t[1] +1
    peak  <- cbind(peak, tk)
    t1    <- which.max(sil[peak[1, ]])
    kclus <- peak[1, t1]
  } else {
    for(j in 1:(length(slope)-1)) {
      if(slope[j] >=0 && slope[j+1] <=0) {
        temp <- j+1
        peak <- cbind(peak, temp)
      }
    }
    t1 <- which.max(sil[peak[1, ]])
    kclus <- peak[1, t1]
  }

  tname <- paste0("K=", row.names(values))

  max.k <- length(sil) + 1

  k.vector <- 2:max.k

  n.samples <- ncol(all_exp)

  if(n.samples < 900) {
    fig.height <- 1200
  } else {
    # Rounding to a negative number of digits means rounding to a power of ten,
    # round(x, digits = -2) rounds to the nearest hundred.
    fig.height <- round(1200 * (1.2 * (n.samples / 1000)), digits=-2)
  }

  # nils: Open device and create canvas for silhouette figure.
  CairoPNG(paste0(output, ".silfig.png"), width=1200, height=fig.height)

  # nils: Split canvas into two columns.
  # par(mai = c(0.9, 0.9, 0.2, 0.2), mfrow = c(1, 2))
  layout(matrix(c(1, 3, 2, 3), 2, 2, byrow=TRUE))

  # nils: Plot "boxes" for each silhouette values. Because each value is only a scalar there
  # will only be lines. By replacing sil with sil_all we would get boxes.
  #boxplot(sil, names=tname, main="Average silhouette value in each cluster", ylab="Silhouette value")

  # nils: Mark the k that has been chosen as the best k with a red dot (the report is talking
  # about a "blue" marker - not sure why).
  #points(kclus, sil[kclus], pch=18, col="red", bg="red", cex=2.5)

  plot(k.vector, sil, main="Average silhouette value in each cluster", xlab="k", ylab="silhouette width", type="n")
  lines(k.vector, sil, type="l", col="black")
  points(k.vector, sil, pch=22, type="p", cex=1.25, bg="black", col="black")
  points((kclus+1), sil[kclus], pch=18, col="red", bg="red", cex=2.5)

  plot(k.vector, values[, 1], main ="Cophenetic Coefficient in each cluster", xlab="k", ylab="Cophenetic Coefficient", type="n")
  lines(k.vector, values[, 1], type="l", col="black")
  points(k.vector, values[, 1], pch=22, type="p", cex=1.25, bg="black", col="black")
  points((kclus+1), values[(kclus), 1], pch=18, col="red", bg="red", cex=2.5)

  #dev.off()
  #line1 <- as.numeric(t)+1
  #line1 <- paste0("#The best cluster is K=", line1)
  #print("finished")

  # nils: Save the sample-to-cluster assignment for the best k.
  cluster.mem <- cluster.mem[order(cluster.mem[kclus]), ]

  fdist <- fdist[rownames(cluster.mem), rownames(cluster.mem)]

  clubest <- cluster.mem[, kclus]

  # nils: Save the silhouette values for the best cluster assingment.
  silbest <- sil_all[, kclus]

  # nils: Create a table of the best silhouette values and best cluster assignments.
  all.best <- cbind(SampleName=rownames(cluster.mem), cluster=clubest, silhouetteValue=silbest)

  group.color <- getColor(all.best[, "cluster"])

  # nils: Compute the silhouette values (again???) for the best cluster assignment.
  # This might be done to get the whole silhouette object for plotting further down.
  clu_si <- silhouette(clubest, fdist)

  # nils: Plot silhouettes for best clustering.
  plot(clu_si, col=group.color, main="Silhouette value for each sample in best cluster")

  # nils: Close device (i.e. write the file).
  dev.off()

  # find markers
  all.best <- all.best[order(all.best[, "cluster"]), ]

  cormatrix <- cormatrix[as.character(all.best[, "SampleName"]), as.character(all.best[, "SampleName"])]

  CairoPNG(paste0(output, ".cormatrix.png"), width=800, height=800)

  blue.white.red.gradient <-colorRampPalette(c("blue", "white", "red"))

  heatmap.2(cormatrix, col=blue.white.red.gradient(100), Rowv=FALSE, Colv="Rowv", scale="none",
            labRow="", labCol="", xlab="Samples", ylab="Samples", ColSideColors=group.color,
            key=TRUE, dendrogram="none", density.info="none", trace="none", breaks=seq(-1, 1, 0.02),
            symbreaks=TRUE, symkey=TRUE)
  dev.off()

  write.table(all.best, file=paste0(output, ".bestclus.txt"), sep="\t", quote=FALSE,
              row.names=FALSE, col.names=TRUE)

  t.positive <- which(as.numeric(all.best[, "silhouetteValue"]) >= 0)

  all.best.orig <- all.best

  # filter
  all.best      <- all.best[t.positive, ]

  vectors       <- unique(all.best[, "cluster"])

  all.t.test    <- NULL
  sig.t.test    <- NULL

  for (i in 1:length(vectors)) {
    tid <- which(all.best[, "cluster"] %in% vectors[i])
    if(length(tid) > 5) {
      tumor_id  <- which(colnames(all_exp) %in% all.best[tid, 1])
      normal_id <- which(colnames(all_exp) %in% all.best[-tid, 1])

      t.vals   <- run_t_test(all_exp, tumor_id, normal_id)
      t.vals   <- as.data.frame(t.vals)

      t.vals$p          <- as.numeric(t.vals$p)
      t.vals$difference <- as.numeric(t.vals$difference)

      tna      <- which(is.na(t.vals$difference))
      if(length(tna) > 0) {
        t.vals <- t.vals[-tna, ]
      }

      # adjust p.value according to Benjamini & Hochberg (1995)
      t.vals$q <- p.adjust(t.vals[, "p"], "BH")

      # filter for significant, if found
      t.sig <- which(t.vals$p <= 0.05 & t.vals$q <= 0.25)
      if(length(t.sig) > 0) {
        t.vals <- t.vals[t.sig, ]
      }

      # if number of tests exceeds 300
      if(nrow(t.vals) > 300 ) {
        pos <- which(t.vals$difference >= 0)
        if(length(pos) > 0 & length(pos) < nrow(t.vals)) {
          # separate positive and negative difference
          m.pos <- t.vals[pos, ]
          # sort by q-value
          m.pos <- m.pos[order(m.pos$q), ]

          m.neg <- t.vals[-pos, ]
          m.neg <- m.neg[order(m.neg$q), ]

          # trim to 150
          if(nrow(m.pos) >= 150) {
            m.pos <- m.pos[1:150, ]
          }

          if(nrow(m.neg) >= 150) {
            m.neg <- m.neg[1:150, ]
          }

          sig.t.vals <- rbind(m.pos, m.neg)
          sig.t.vals <- cbind(sig.t.vals, cluster=rep(vectors[i], nrow(sig.t.vals)))

          t.vals$cluster <- rep(vectors[i], nrow(t.vals))

          all.t.test <- rbind(all.t.test, t.vals)
          sig.t.test <- rbind(sig.t.test, sig.t.vals)
        } else {
          t.vals$cluster <- rep(vectors[i], nrow(t.vals))
          all.t.test     <- rbind(all.t.test, t.vals)
          sig.t.test     <- all.t.test
        }
      }
      else {
        t.vals         <- t.vals[order(t.vals$difference, decreasing=TRUE), ]
        t.vals$cluster <- rep(vectors[i], nrow(t.vals))
        all.t.test     <- rbind(all.t.test, t.vals)
        sig.t.test     <- all.t.test
      }
    }

  }

  selectmarker.names        <- c("Hybridization REF", "p", "difference", "q", "subclass")
  subclassmarkers.names     <- selectmarker.names
  subclassmarkers.names[1]  <- "Composite Element REF"

  if(!is.null(all.t.test)) {
    # set col.names
    colnames(all.t.test) <- selectmarker.names
    colnames(sig.t.test) <- subclassmarkers.names

    write.table(all.t.test, file=paste0(output, ".subclassmarkers.txt"), sep="\t", quote=FALSE, row.names=FALSE)
    write.table(sig.t.test, file=paste0(output, ".selectmarker.txt"), sep="\t", quote=FALSE, row.names=FALSE)

    map.exp <- all_exp[sig.t.test[, 1], all.best.orig[, 1]]

  } else {

    all.t.test.empty <- setNames(data.frame(matrix(ncol=length(subclassmarkers.names), nrow=0)), subclassmarkers.names)
    sig.t.test.empty <- setNames(data.frame(matrix(ncol=length(selectmarker.names), nrow=0)), selectmarker.names)

    write.table(all.t.test, file=paste0(output, ".subclassmarkers.txt"), sep="\t", quote=FALSE, row.names=FALSE)
    write.table(sig.t.test, file=paste0(output, ".selectmarker.txt"), sep="\t", quote=FALSE, row.names=FALSE)

    map.exp <- all_exp[, all.best.orig[, 1]]

  }

  map.exp <- apply(map.exp, 2, as.numeric)
  map.exp <- scale(t(map.exp), center=TRUE, scale=FALSE)
  map.exp <- t(map.exp)

  q.num   <- quantile(map.exp, c(0.1, 0.9), na.rm=TRUE)

  map.exp[map.exp >= q.num[2]] <- q.num[2]
  map.exp[map.exp <= q.num[1]] <- q.num[1]

  CairoPNG(paste0(output, ".geneheatmap.png"), width=1800, height=1600)

  if(!is.null(all.t.test)) {

    rowside <- getColor(as.character(sig.t.test[, 5]))

    if(nrow(map.exp) == 0) {
      plot()
    }
    # plot with row side colors
    heatmap.2(map.exp, col=blue.white.red.gradient(100), Rowv=FALSE, Colv="Rowv", scale="none",
              labRow="", labCol="", xlab="Samples", ylab="Genes", ColSideColors=group.color,
              RowSideColors=rowside, key=TRUE, dendrogram="none", density.info="none",
              trace="none", na.rm=TRUE)
    dev.off()
  } else {
    # plot without row side colors
    heatmap.2(map.exp, col=blue.white.red.gradient(100), Rowv=FALSE, Colv="Rowv", scale="none",
              labRow="", labCol="", xlab="Samples", ylab="Genes", ColSideColors=group.color,
              key=TRUE, dendrogram="none", density.info="none", trace="none", na.rm=TRUE)
    dev.off()
  }

  q.num <- quantile(dism, c(0.1, 0.9), na.rm=TRUE)

  # If the lower and upper qauntiles are not the same,
  # continue with the normalization, otherwise skip
  if (q.num[2] != q.num[1] ) {
    dism[dism >= q.num[2]] <- q.num[2]
    dism[dism <= q.num[1]] <- q.num[1]
  }

  dism <- dism[, all.best.orig[, 1]]
  dism[is.na(dism)] <- 0

  CairoPNG(paste0(output, ".geneheatmaptopgenes.png"), width=2500, height=2000)

  heatmap.2(dism, col=blue.white.red.gradient(100), Rowv=TRUE, Colv=FALSE, scale="none",
            labRow="", labCol="", xlab="Samples", ylab="Genes", ColSideColors=group.color,
            key=TRUE, dendrogram="none", density.info="none", trace="none", na.rm=TRUE)
  dev.off()
}


run_t_test <- function(exp, tumor_id, normal_id) {
  exp.genes <- NULL

  t_test <- function(i, exp, tumor_id, normal_id) {
    #print(i)
    na.tumor  <- sum(is.na(exp[i, tumor_id]))
    na.normal <- sum(is.na(exp[i, normal_id]))
    l.tumor   <- length(tumor_id)
    l.normal  <- length(normal_id)

    if (na.tumor > 0.7 * l.tumor | (l.tumor-na.tumor) < 3 |
        na.normal > 0.7 * l.normal | (l.normal - na.normal) < 3) {
          resp <- c(GeneName=as.character(rownames(exp)[i]), p=NA, difference=NA)
    } else {
      t <- try(t.test(as.numeric(exp[i, tumor_id]), as.numeric(exp[i, normal_id]), na.rm=TRUE), silent=TRUE)
      if(class(t) == "try-error") {
        resp <- c(GeneName=as.character(rownames(exp)[i]), p=NA, difference=NA)
      } else {
        distance <- t[["estimate"]]["mean of x"] - t[["estimate"]]["mean of y"]
        resp <- c(GeneName=as.character(rownames(exp)[i]), p=t[["p.value"]], difference=distance)
      }
    }
    return(resp)
  }

  exp.genes.xl <- lapply(1:nrow(exp), t_test, exp, tumor_id, normal_id)

  exp.genes    <- do.call(rbind, exp.genes.xl)

  colnames(exp.genes) <- c("GeneName", "p", "difference")

  return(exp.genes)
}


read.data <- function(fn, suffix.dup=FALSE) {
  check  <- readLines(fn, n=1)
  check0 <- strsplit(check, "\t")[[1]][1]
  if (check0 == "#1.2") {
    check <- readLines(fn, n=3)[3]
    mat   <- read.delim(fn, as.is=TRUE, skip=3, header=FALSE)
    gnms  <- toupper(mat[, 1])
    mat   <- mat[, -(1:2), drop=FALSE]
    dnms  <- toupper(strsplit(check, "\t")[[1]][-(1:2)])
  } else {
    check2 <- readLines(fn, n=2)[2]
    check2 <- toupper(strsplit(check2, "\t")[[1]])
    nskip  <- ifelse(grepl("COMPOSITE *ELEMENT REF", check2[1]), 2, 1)
    mat    <- read.delim(fn, as.is=TRUE, skip=nskip, header=FALSE)
    gnms   <- toupper(mat[, 1])
    mat    <- mat[, -1, drop=FALSE]
    dnms   <- toupper(strsplit(check, "\t")[[1]][-1])
  }
  # Fix excel data issues
  ind <- grep("^\\d+-SEP$", gnms)
  if(length(ind) > 0) {
    tmp <- gnms[ind]
    tmp <- sub("-SEP", "", tmp)
    tmp <- sprintf("SEPT%s", tmp)
    gnms[ind] <- tmp
  }

  ind <- grep("^\\d+-MAR$", gnms)
  if(length(ind) > 0) {
    tmp <- gnms[ind]
    tmp <- sub("-MAR", "", tmp)
    tmp <- sprintf("MARCH%s", tmp)
    gnms[ind] <- tmp
  }

  ind <- grep("^\\d+-APR$", gnms)
  if(length(ind) > 0) {
    tmp <- gnms[ind]
    tmp <- sub("-APR", "", tmp)
    tmp <- sprintf("APR-%s", tmp)
    gnms[ind] <- tmp
  }

  mat <- as.matrix(mat)
  # not sure about the required use-case
  if (suffix.dup) {
    dup  <- rep(0, nrow(mat))
    gnm2 <- gnms
    ii   <- which(duplicated(gnm2))
    dup[ii] <- dup[ii]+1
    while(length(ii)>0) {
      gnm2 <- paste(gnms, dup, sep="__")
      ii   <- which(duplicated(gnm2))
      dup[ii] <- dup[ii]+1
    }
    gnm2 <- sub("\\__0$", "", gnm2)
    rownames(mat) <- gnm2
  } else rownames(mat)=gnms

  colnames(mat) <- dnms
  return(mat)
}

getColor <- function(subType, col=c("purple", "darkgreen", "red", "blue", "green", "magenta1", "black", "yellow", "orangered", "brown"),
                     cNames=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10")) {
    names(col) <- cNames
    return(col[subType])
}

opt  <- parse_args(OptionParser(option_list=option.list, usage="Rscript %prog [options]"), print_help_and_exit=FALSE)

# replace gplots::heatmap.2 function with modified version to skip unecessary dendrogram
# creation and use the order defined in the supplied matrix.
if(!is.na(opt$libdir)) {
  source(file.path(opt$libdir, "heatmap2-301-fixed.R"))
  #source(file.path(opt$libdir, "heatmap2-r2153.R"))
}

main(opt)
